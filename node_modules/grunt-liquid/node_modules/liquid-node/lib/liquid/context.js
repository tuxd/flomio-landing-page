// Generated by CoffeeScript 1.4.0
(function() {
  var Context, Liquid, Q, _,
    __slice = [].slice;

  Liquid = require("../liquid");

  _ = require("underscore")._;

  Q = require("q");

  module.exports = Context = (function() {

    function Context(environments, outerScope, registers, rethrowErrors) {
      if (environments == null) {
        environments = {};
      }
      if (outerScope == null) {
        outerScope = {};
      }
      if (registers == null) {
        registers = {};
      }
      if (rethrowErrors == null) {
        rethrowErrors = false;
      }
      this.environments = _.flatten([environments]);
      this.scopes = [outerScope || {}];
      this.registers = registers;
      this.errors = [];
      this.rethrowErrors = rethrowErrors;
      this.strainer = Liquid.Strainer.create(this);
      this.squashInstanceAssignsWithEnvironments();
    }

    Context.prototype.addFilters = function(filters) {
      var _this = this;
      filters = _([filters]).chain().flatten().compact().value();
      return filters.forEach(function(filter) {
        if (!(filter instanceof Object)) {
          throw new Error("Expected Object but got: " + (typeof filter));
        }
        return _.extend(_this.strainer, filter);
      });
    };

    Context.prototype.handleError = function(e) {
      this.errors.push(e);
      if (this.rethrowErrors) {
        throw e;
      }
      if (e instanceof Liquid.SyntaxError) {
        return "Liquid syntax error: " + e.message;
      } else {
        return "Liquid error: " + e.message;
      }
    };

    Context.prototype.invoke = function() {
      var args, f, method;
      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.strainer[method] != null) {
        f = this.strainer[method];
        return f.apply(this.strainer, args);
      } else {
        return args != null ? args[0] : void 0;
      }
    };

    Context.prototype.push = function(newScope) {
      if (newScope == null) {
        newScope = {};
      }
      Liquid.log("SCOPE PUSH");
      this.scopes.unshift(newScope);
      if (this.scopes.length > 100) {
        throw new Error("Nesting too deep");
      }
    };

    Context.prototype.merge = function(newScope) {
      if (newScope == null) {
        newScope = {};
      }
      return _(this.scopes[0]).extend(newScope);
    };

    Context.prototype.pop = function() {
      Liquid.log("SCOPE POP");
      if (this.scopes.length <= 1) {
        throw new Error("ContextError");
      }
      return this.scopes.shift();
    };

    Context.prototype.lastScope = function() {
      return this.scopes[this.scopes.length - 1];
    };

    Context.prototype.stack = function(newScope, f) {
      var popLater, result,
        _this = this;
      if (newScope == null) {
        newScope = {};
      }
      popLater = false;
      try {
        if (arguments.length < 2) {
          f = newScope;
          newScope = {};
        }
        this.push(newScope);
        result = f();
        if (Q.isPromise(result)) {
          popLater = true;
          result.nodeify(function() {
            return _this.pop();
          });
        }
        return result;
      } finally {
        if (!popLater) {
          this.pop();
        }
      }
    };

    Context.prototype.clearInstanceAssigns = function() {
      return this.scopes[0] = {};
    };

    Context.prototype.set = function(key, value) {
      Liquid.log("[SET] %s %j", key, value);
      return this.scopes[0][key] = value;
    };

    Context.prototype.get = function(key) {
      var value;
      value = this.resolve(key);
      Liquid.log("[GET] %s %j", key, value);
      return value;
    };

    Context.prototype.hasKey = function(key) {
      return !!this.resolve(key);
    };

    Context.Literals = {
      'null': null,
      'nil': null,
      '': null,
      'true': true,
      'false': false,
      'empty': function(v) {
        return !((v != null ? v.length : void 0) > 0);
      },
      'blank': function(v) {
        return !v || v.toString().length === 0;
      }
    };

    Context.prototype.resolve = function(key) {
      var hi, lo, match;
      if (Liquid.Context.Literals.hasOwnProperty(key)) {
        return Liquid.Context.Literals[key];
      } else if (match = /^'(.*)'$/.exec(key)) {
        return match[1];
      } else if (match = /^"(.*)"$/.exec(key)) {
        return match[1];
      } else if (match = /^(\d+)$/.exec(key)) {
        return Number(match[1]);
      } else if (match = /^\((\S+)\.\.(\S+)\)$/.exec(key)) {
        lo = Number(resolve(match[1]));
        hi = Number(resolve(match[2]));
        throw new Error("Ranges are not supported.");
      } else if (match = /^(\d[\d\.]+)$/.exec(key)) {
        return Number(match[1]);
      } else {
        return this.variable(key);
      }
    };

    Context.prototype.findVariable = function(key) {
      var scope, variable,
        _this = this;
      scope = _(this.scopes).detect(function(scope) {
        return scope.hasOwnProperty(key);
      });
      variable = void 0;
      if (scope == null) {
        scope = _(this.environments).detect(function(env) {
          variable = _this.lookupAndEvaluate(env, key);
          return variable != null;
        });
      }
      if (scope == null) {
        scope = _(this.environments).last || _(this.scopes).last;
      }
      if (variable == null) {
        variable = this.lookupAndEvaluate(scope, key);
      }
      return Q.when(variable).then(this.liquify.bind(this));
    };

    Context.prototype.variable = function(markup) {
      var _this = this;
      return Q.fcall(function() {
        var firstPart, iterator, mapper, match, object, parts, squareBracketed;
        parts = Liquid.Helpers.scan(markup, Liquid.VariableParser);
        squareBracketed = /^\[(.*)\]$/;
        firstPart = parts.shift();
        if (match = squareBracketed.exec(firstPart)) {
          firstPart = match[1];
        }
        object = _this.findVariable(firstPart);
        if (parts.length === 0) {
          return object;
        }
        mapper = function(part, object) {
          if (object == null) {
            return Q.when(object);
          }
          return Q.when(object).then(_this.liquify.bind(_this)).then(function(object) {
            var bracketMatch;
            if (object == null) {
              return object;
            }
            bracketMatch = squareBracketed.exec(part);
            if (bracketMatch) {
              part = _this.resolve(bracketMatch[1]);
            }
            return Q.when(part).then(function(part) {
              var isArrayAccess, isObjectAccess, isSpecialAccess;
              isArrayAccess = _.isArray(object) && _.isNumber(part);
              isObjectAccess = _.isObject(object) && (part in object);
              isSpecialAccess = !bracketMatch && object && (_.isArray(object) || _.isString(object)) && ["size", "first", "last"].indexOf(part) >= 0;
              if (isArrayAccess || isObjectAccess) {
                return Q.when(_this.lookupAndEvaluate(object, part)).then(_this.liquify.bind(_this));
              } else if (isSpecialAccess) {
                switch (part) {
                  case "size":
                    return _this.liquify(object.length);
                  case "first":
                    return _this.liquify(object[0]);
                  case "last":
                    return _this.liquify(object[object.length - 1]);
                  default:
                    throw new Error("Unknown special accessor: " + part);
                }
              }
            });
          });
        };
        iterator = function(object, index) {
          if (index < parts.length) {
            return mapper(parts[index], object).then(function(object) {
              return iterator(object, index + 1);
            });
          } else {
            return Q.when(object);
          }
        };
        return iterator(object, 0).then(null, function(err) {
          throw new Error("Couldn't walk variable: " + markup + ": " + err);
        });
      });
    };

    Context.prototype.lookupAndEvaluate = function(obj, key) {
      var value;
      value = obj[key];
      if (typeof value === 'function') {
        return obj[key] = value.call(obj, this);
      } else {
        return value;
      }
    };

    Context.prototype.squashInstanceAssignsWithEnvironments = function() {
      var lastScope,
        _this = this;
      lastScope = this.lastScope();
      return _(lastScope).chain().keys().forEach(function(key) {
        return _(_this.environments).detect(function(env) {
          if (env.hasOwnProperty(key)) {
            lastScope[key] = _this.lookupAndEvaluate(env, key);
            return true;
          }
        });
      });
    };

    Context.prototype.liquify = function(object) {
      var _this = this;
      return Q.when(object).then(function(object) {
        if (object == null) {
          return object;
        } else if (typeof object.toLiquid === "function") {
          object = object.toLiquid();
        } else if (typeof object === "object") {
          true;
        }
        if (object instanceof Liquid.Drop) {
          object.context = _this;
        }
        return object;
      });
    };

    return Context;

  })();

}).call(this);
